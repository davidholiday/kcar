#set( $symbol_pound = '#' )
#set( $symbol_dollar = '$' )
#set( $symbol_escape = '\' )


${symbol_pound} all properties are namespaced to the artifact name so when included in a service, there aren't conflicts between
${symbol_pound} any of the included properties files.


${symbol_pound} when the app is bootstrapped, this file is parsed to see what routes to create. routes are created dynamically by
${symbol_pound} class name. they are also identified by same.
${symbol_pound}
${symbol_pound} the punchline to all this is that we can get the effect of IoC without having to deal with Guice, Spring, or any
${symbol_pound} other framework.


${symbol_pound}${symbol_pound} map in the form <K,V>
${symbol_pound}${symbol_pound}   K = the properties namespace (always the camel-cased classname)
${symbol_pound}${symbol_pound}   V = the fully qualified class name of the route
${symbol_pound}${symbol_pound}
${symbol_pound}${symbol_pound} this allows the both the route and the route's properties file to be loaded dynamically
${symbol_pound}modelK.routesMap = healthCheckRoute=io.holitek.kcar.routes.HealthCheckRoute


${symbol_pound} comma-delimited list of routes to instantiate
__artifactIdCamelCase__.routes = io.holitek.kcar.routes.HealthCheckRoute